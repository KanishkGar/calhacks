0:03
all right welcome everybody uh to a new term um we seem to have somehow managed to
0:10
get 292 people so far on the um on the zoom that's pretty impressive
0:17
um i'm going to uh be uh basically lecturing um twice a
0:24
week from here and hopefully this will work out well feel free
0:29
i think to avoid the chaos let's have people uh type their questions in chat i have two
0:34
screens so i can kind of watch and uh let's just see how this goes if everybody's ready
0:40
so uh welcome to the uh virtual version of cs162 i guess since
0:47
we talked about virtualization this is uh particularly appropriate um can i get a couple of uh thumbs up or
0:54
something in the chat just to make sure that the sound is good with everybody and please disable your cameras if you
0:59
could um all right great so my name is john kubatowicz i'll introduce myself a
1:05
little bit later but um today what we're going to do is uh we're going to dive right in and kind of
1:11
ask some questions like what an operating system is since you guys are taking this class in theory and maybe we'll say something about what
1:18
it's not um we're going to try to give you some ideas of why i find operating systems so
1:23
exciting and uh oh and we'll tell you a little bit about the class but let's dive right in before we
1:29
get uh to the operational parts of the class um and i want to point out that
1:34
interaction is very important this is going to be kind of hard uh even when i teach live normally
1:41
um the interaction portion of this uh is challenging on the first day but once
1:47
we get into the second day um i think uh our second time
1:52
i think we should be able to ask a lot of questions it'll be great so um there's question about whether
1:58
slides are going to be posted yes we're going to post both the slides and the videos um still getting
2:03
things um moving forward here uh but let's um keep in mind that you're
2:10
free to ask questions and let's move forward so um first of all let's start with this
2:17
which is uh what i like to call the greatest artifact of human civilization um does anybody recognize what this
2:23
might be do we have any thoughts other than random yeah very good we've got
2:31
several people that basically said internet and in fact there it is so what's a great uh about
2:37
this is that we have billions of people all and and devices all interconnected in
2:45
one huge system and uh lest you think this is a plug for one um 68 or 268
2:53
this is uh you know the networking is just uh one of the amazing aspects of this
2:59
huge system and the operating systems are really what makes ties it all together and essentially uh ties everybody else
3:06
together which is part of what's very cool about the internet and of course you're all off on the internet right now this is
3:12
all entirely virtual so i guess it's kind of appropriate to start a class this way um and i i had
3:18
a couple of people comment that this looks like a big brain yes in some sense it does it's got uh huge
3:24
numbers of uh connections and interconnectivity and multiple redundancies and so
3:29
the notion of this as a brain is not entirely off base i think what we're going to try to do as
3:35
the term goes on we're going to try to tame some of the complexity that's hidden inside uh both the internet and the devices on
3:42
it and see how to understand it um so you know basically if this were 168 we
3:50
would probably dwell on slides like this but this is pretty impressive kind of the original arpanet
3:56
couldn't handle more than 256 devices and uh now we've got
4:02
um you know billions four and a half billion devices penetrating maybe
4:08
sixty percent of the world uh which is just astounding uh place to come and
4:14
um you know some of the deadlines here or some of the dates that are particularly interesting in here is i think in the sort of the
4:21
very early 90s is when the world wide web took off and that was when suddenly the internet became something that
4:27
lots of people could use and um and turned it into what it is today um
4:34
the other thing that's kind of interesting which uh is in this this picture as well is this idea of the
4:40
diversity of devices there are literally this is a graph kind of of
4:45
um the uh sometimes i like to call this colors graph or it's bell's
4:51
law which is the number of devices uh that a person has
4:56
and if you look originally it was kind of one computer for millions of people back in
5:02
the original day and then as things moved down now each of you probably has hundreds of devices
5:09
that are working for you um modern cars have hundreds of processors in them you all have cell
5:14
phones and laptops and um and little computers inside of devices and thermostats and so on and so
5:21
this this graph is kind of funny it's almost an inverse moore's law graph where um the number of uh computers per person
5:30
is uh increasing as they get smaller which is kind of interesting um and there's a lot of time scales and
5:36
so when we start talking about how to make this whole system work we're going to have to figure out how to deal with something that's uh you know nanoseconds
5:44
or femtoseconds in some cases up to things that are seconds and and tens of seconds um and
5:53
somehow the system's got to work across those time scales and that's there's a little magic involved
5:58
in that and we're going to try to talk about this i did see somebody say femtoseconds no way but a lot of the laser communications uh
6:06
do operate very rapidly um so we'll we'll hold off on the femtoseconds here but
6:12
sub nanoseconds definitely these days all right now operating systems are really at the
6:17
heart of all of this basically you make incredible advances
6:22
continuously in the underlying technology and what happens is somehow each
6:30
device is a little bit different every technology generation generations a little different and you got to provide uh somehow a
6:38
consistent programming abstraction to applications no matter how complicated the hardware is
6:43
and you gotta manage sharing of resources okay so the more devices we have connected the more resources there
6:49
are to share and as we get closer to the end of the term so i'm going to say the last third of the term
6:54
we're going to start talking about some of these uh very interesting peer-to-peer systems
7:00
that are out there that basically allows us to
7:08
have huge storage systems that span many devices i did see some questions about postings
7:15
of slides we will definitely um in the future i'll have them up earlier than um the day after lecture uh so some of
7:21
the key building blocks to operating systems are really uh things that we're gonna we're gonna learn about in class uh
7:28
processes threads concurrency scheduling coordination many of these things you've learned about in the 61 series
7:35
address spaces protection isolation sharing security and that level of security is
7:41
going to be both at the device level and then as we build out into the network you know we'll talk about things
7:46
like ssl and then we'll talk about uh more interesting security models as we go
7:52
and there's going to be communication protocols um there's going to be persistent storage
7:58
um there's projects i've worked on in the past i'll mention briefly later where it was interested the
8:03
interesting question was how do you store information for thousands of years without it being destroyed
8:10
we'll talk about transactions and consistency and resilience and interfaces to all these devices so this is um a
8:17
class that spans a lot of interesting topics all right and so for instance here's something you do every day without
8:23
thinking about it multiple times you got your cell phone and you want to look up something uh on some device
8:31
uh you know web you know a web page or maybe you're using an app and what happens there well the first
8:37
thing that happens is uh there's a dns request that tries to figure out what the uh internet ip address is to
8:45
where you're trying to go and that goes to a bunch of dns servers uh on the network and they return
8:51
information that helps now your say cell phone route through the internet which is a very
8:56
interesting uh device in and of itself consisting of many pieces um and that may go to a data center
9:02
somewhere with a load balancer that then will pick one of several possible devices out there
9:08
which will then maybe do your search and retrieve information from a page store put it back together
9:15
into some uh page that you can use and then you get the result back and you know you do this every day and
9:21
don't really think about it too much and uh once you start thinking about it gets pretty interesting like for
9:26
instance how is it that those dns servers stay consistent and why is it that it's not possible to hack into them well
9:33
in fact uh back in the middle 2000's people were hacking into them i'll tell you a little bit about that later
9:40
um and how do you make sure that the packets get enough uh priority when they come into an
9:45
operating system that maybe your your particular query doesn't get delayed
9:50
a long time so there's some scheduling questions so this is a pretty complex system and it's every time i spend
9:58
the time to think about it i'm amazed it works okay it's pretty impressive and hopefully by
10:03
the end of this class you'll have enough knowledge of what's going on in all parts of the operating systems and the networks that you too
10:10
you know you'll be much smarter than when you started the class of course but um you'll be able to appreciate and
10:15
sometimes maybe uh wonder why it is that it actually manages to work or be impressed that it works so
10:23
yeah but what's an operating system okay um what does it do we could ask that question um so most likely you could you
10:30
could say well from the standpoint of what it does this is like being a physicist that's maybe measuring a bunch of things you say well
10:37
it's memory management it's io management it does scheduling does communication
10:43
um does multitasking or multi-programming um you could you could ask those things
10:50
you might ask is an operating system about the file system or about multimedia or about the
10:56
windowing system or the browser you know back in the 90s there was a lot
11:02
of fighting between microsoft and bunch of other companies about does the internet browser
11:08
constitute part of the operating system and you know depending on your point of view
11:13
that may still not be a resolved question but um anyway it was one that has been asked
11:18
so um and also i would ask everybody to turn off their video if they could please while they're while we're talking so um
11:27
so is this you know these questions only interesting to academics it's a question you might ask um okay so
11:35
uh hopefully not hopefully it's interesting to you um could i ask the person just came in turn off your camera
11:41
please or turn off your video because that will show up in the recording
11:47
so a definition of an operating system is uh no universally accepted definition is
11:52
part here everything a vendor ships when you order an operating system might be a good approximation uh but it
11:59
varies pretty widely um it might be the one program running at all times on
12:05
the computer okay uh that's the kernel you'll learn a lot about kernels as the term goes on
12:11
uh but you can see these two points of view are are different um you know
12:18
nobody would disagree that the kernel is uh the core of the operating system they would disagree pretty widely about is
12:26
everything that microsoft ships with a windows product part of the operating system
12:31
okay probably not all right so you know as we try to to
12:39
drill down onto what an operating system is you're gonna have to keep in mind that we're gonna talk about things it does and pieces that are
12:45
important but maybe you'll never fully know what an operating system is um so it's a typically uh among other
12:53
things a special layer of software that provides the application access to hardware resources all right
12:58
so it's convenient abstractions of complex hardware devices um protected
13:04
access to shared resources okay security and authentication yeah
13:09
communication okay uh so we could look at something like this where we have some hardware
13:15
and it's the fact that many applications can simultaneously run on the hardware is something that the os
13:22
has provided for us okay so yeah that makes sense and you will understand exactly how this works
13:28
uh actually in a few weeks um but maybe we could do it this way well
13:33
operating system what's the first word operating well that comes actually from uh there
13:39
used to be people like there was a switchboard operator believe it or not when you made a phone call they actually had to plug you in to
13:45
the right connection and make the wires connect then there were computer operators which
13:50
were people that basically sat at one of these big machines for a long time and uh made sure it was running
13:56
correctly um and then of course operating systems
14:01
uh the operating part of it then became more about well we're making sure that the disk is operating quickly or the
14:08
network is operating correctly or the graphics cards are operating correctly all right um what about the
14:16
word system well this is interesting as well so what makes a system so a system
14:21
is something with many interrelated parts where typically the sum is much greater than the sum of its
14:27
parts and uh every interrelated part potentially interacts with others
14:33
and of course that's an n squared uh level of complexity at least
14:38
and we're going to have to come up with apis and uh other clever techniques to avoid
14:44
n squared complexity here because things are complex enough as it is um and making a system which i showed
14:52
you earlier the internet that's a system that has billions of components to make it robust
14:58
and not fail is going to require an engineering mindset so you guys are going to have to start thinking like engineers
15:04
and we're going to give you some tools to really think about how to make something that complicated
15:10
actually work um again the internet is something which you know it's a great example of a
15:15
big system that is amazing that it works and it's actually it doesn't always work i i'll pull up some stories later in the
15:22
term about times where it definitely didn't work my favorite being one time where there was a single optical fiber that divided
15:29
the network into two pieces and it went through this tunnel in the middle of the country the u.s and
15:35
a truck went in and blew up and it melted this fiber and it actually temporarily partitioned the network
15:41
so um there are times when it just doesn't work properly okay so uh systems programming
15:48
is an important part of this class and you're gonna do a lot of it okay you're gonna learn how to take a system like
15:53
this and figure out exactly how to make it work and that's um that's exciting okay you're going to get
15:59
some of the tools you're going to learn about git you're going to learn about how to work in groups you're going to learn about
16:04
testing and all of these things that help to make a complex system actually manageable and hopefully
16:10
eventually workable okay so so part of making things work are
16:18
interfaces so here's a 61c view maybe of things the hardware software interface
16:23
so you have hardware that's these bricks and they got software which might be a program
16:29
in 61c which hopefully will start coming back to you very rapidly
16:34
you had a processor and you had memory which had the os in it maybe you had uh
16:40
registers in the processor and those registers pointed at parts of memory okay and that allowed this program to
16:47
run uh maybe you had caches we'll we'll learn about caches again and remember mostly remind you how they work
16:54
uh which help to make the slow memory look fast okay the way i like to think about uh
17:01
a system with caches is you want to make it as fast as the smallest item like the registers and as large as
17:08
the largest item like the memory or disk and the way you do that is with uh
17:13
caches okay and of course there's page tables and tlbs which will help us out in virtual memory
17:21
and there's storage disk drives etc there's all sorts of devices like networks and displays and inputs
17:26
and so making all of this tie together is something you started down the path with 61c hopefully you remember that
17:34
um and then of course there's interesting things like buses that tie it all together okay and i you
17:39
know 61c doesn't quite get into that level of detail and we're not going to do that too much i might suggest 152
17:46
and 151 some of those interesting classes uh if you really want to talk about the
17:52
maybe 150 if you want to talk about the buses and so on but then of course there's an instruction set architecture which you
17:59
did talk about and that abstracts away a lot of what's going on in the processor so that
18:04
people running programs and compilers that are compiling programs have something common
18:10
to use okay and so what you learned in 61c was machine structures and you also learned c which
18:17
you're going to get to exploit a lot so i know the notion that in 61c you
18:24
learn c is maybe a shared with a little bit of skepticism by people
18:30
but um you're going to get to learn it a lot more in this class
18:36
so the os abstracts the hardware details from the application so not just the
18:41
instruction set architecture is going to matter anymore so that abstracts away the computation elements of the
18:47
processor but we're going to learn how to turn a bunch of storage devices like disks and usb
18:53
keys and um cloud storage and turn it into a single abstraction like say a
18:59
file system so that a user can use that easily without having to worry about where the bits are stored
19:04
okay and so that's where we go with this classes we're going to learn not just about the abstractions from
19:10
hardware for 61c but ups and processor but abstractions uh for other devices as well
19:18
okay so what is an operating system so let's go through some things it does
19:26
again let's try to maybe get an idea operationally so one thing that i've started to talk about here is the fact that the
19:32
operating system is an illusionist in some sense all right it's going to provide clean easy to use abstractions of physical
19:38
resources and it's going to do so in a way that allow you to at least temporarily think
19:43
that you've got infinite memory you have a machine entirely dedicated to you or a processor
19:50
that there are higher level objects like files and users and messages even though as you probably already know but will
19:56
know very well by the end of the term there aren't files or files are an abstraction of a bunch of individual
20:02
blocks on a disk that somehow are put together with inodes to give you a file so the operating system is busy
20:09
providing an illusion of a much more usable machine
20:14
so that when you program it you have a much easier time of it and you don't have to worry so much about
20:20
whether it's on disk or on a usb key or in cloud storage okay and we're going to learn also about
20:26
abstractions of users and messages and we're going to talk about virtualization and how to take the
20:32
limitations of a system and hide them in a way that makes it easy to program
20:38
okay so for instance so um virtualizing the machine so here's our 61c machine
20:45
which has a processor it's got memory it's got i o with maybe storage and networks
20:51
um and on top of it we're going to put this operating system thing which we're learning about as we as we
20:57
speak and that operating system instead of giving us a processor with uh
21:05
limitations the processor has it's you know it's got a certain um set of registers it's
21:11
got uh certain floating point operations it uh has uh certain um exceptions that are caused
21:18
and so on we're going to give an abstraction of something really clean called threads okay um we're going to have
21:26
address spaces uh for instance we're going to learn about rather than a bunch of memory
21:32
bytes that are in dram and scattered about we're going to
21:37
provide a nice clean address space abstraction that will uh give
21:42
us the ability to treat the memory as if it's entirely ours even
21:48
when there's multiple programs running again i just talked about files rather
21:54
than a bunch of individual blocks we're going to have files and rather than networks which are a
21:59
bunch of individual ethernet cards let's say that are connected point-to-point between here and beijing
22:05
we're going to have sockets and routing under the covers okay so that's a pretty clean abstraction
22:10
which of course ultimately allows me to teach uh you guys spread all over the globe as
22:16
you are okay on top of this these threads address
22:21
spaces files and sockets are going to be the process abstraction
22:26
and that process abstraction is going to give us an execution environment with restricted rights
22:32
provided by the operating system and that process abstraction is going to be a nice virtual machine
22:37
that your program can run in that's uh abstracted away from all of these
22:42
physical details okay and so on top of that you could
22:48
have your program so the one thing that you guys get to do a lot more of than you've done
22:54
so far in your career is you get to actually do uh user-level programs running on top
22:59
of a unix environment okay and so um you're gonna have compiled programs
23:05
that you have produced that are going to run on top of your process abstraction and in order to give you a clean
23:12
environment into the process abstraction there'll be system libraries so there's even a system something
23:21
the c library the security libraries many of the libraries abstract even further and give you nice
23:27
clean abstractions that maybe allow you to do ssl very easily or so on okay
23:33
there is an interesting question uh in the chat which i'm going to point out some people are asking about
23:38
closed captioning some classes like last term we even had closed captioning but that's
23:44
when we need it and we actually have a live captioner in that case unfortunately we don't
23:49
but what i will do uh when i put the um videos up is uh they will get
23:55
automatically closed captioned by uh by youtube when i put them on there
24:00
and so that'll be something but they won't be live sorry about that um so this is our
24:06
virtualized machine view and the applications machine is the process abstraction
24:12
provided by the os and some people might argue including the system libraries
24:17
and each running program runs in its own process and the process gives you a very nice
24:23
interface nicer than hardware now the question here on the on the chat here is is the hypervisor or docker demon a part
24:31
of the process acting on as the top layer of the vm so uh we will talk a little bit later in
24:37
the term about docker docker is a way of wrapping up
24:43
uh multiple different little environments and potentially running them inside the process abstraction
24:49
it's not as uh isolated as say a full virtual machine but we'll talk
24:55
we'll talk more about that in detail let's stick with process abstractions for now um the process abstraction is i'll show
25:01
you in a second you can have multiple processes all running uh at the same time and they're each
25:07
given isolation from each other so that's what we're going to start with uh for this first lecture um so
25:14
uh the system uh isa by the way stands for instruction set architecture that was a question
25:20
so uh the system libraries um what does a system programmer think of well the system libraries are linked
25:26
into your program which is then run by a compiler and turned into bits that will run in the process
25:32
you're going to get very uh good at this as well as you're going to learn how to compile programs link them with libraries
25:38
and then execute them in a process environment and you'll learn how to invoke the compiler to do that
25:43
so um this is the programmer's view so what what's in a process so remember
25:50
the process here is an environment right that gives you threads address spaces file sockets so
25:56
um a process as i said has an address space which is a chunk of protected memory it has one
26:02
or more threads in it uh one or more threads of control executing in that address space
26:07
and uh the system state associated with open files and sockets and so on
26:12
and so this is a completely isolated environment we're going to dive into processes very quickly in this class
26:18
and you're going to learn how we can have a protected address space and multiple threads running in an environment
26:25
that's protected from other processes even though for instance maybe there's only one core running we're going to give the
26:32
illusion that there's multiple cores running with multiple processes at the same time so um you've all done this
26:39
you know here's an example on on say a mac uh where you look at the process monitor or
26:45
the task manager or you do a psa ux on linux box and what you see here which
26:51
is uh perhaps surprising if you haven't really thought about it is that um
26:59
there are many processes running all the time on your typical laptops okay so many things going simultaneously
27:06
50 or 100 of them mostly they're sleeping but they're there to wake up and do some
27:11
execution at some point okay now the question of why are the middle
27:18
layers of abstraction necessary so part of the reason that we have many layers of abstraction
27:24
is that if you try to squash all the layers down which is sometimes done in very
27:29
specialized environments you end up with an undebugable mess
27:35
okay and so multiple abstractions assuming they don't make things too slow are a crucial aspect to making things
27:42
actually work properly okay and so you'll see even modern uh
27:48
operating systems still have several abstraction layers okay and you'll you'll appreciate them i think as we go forward
27:54
um because it's much easier to actually have an operating system that has a device
27:59
driver talking to the disk and then you have a file system that provides files and then you have a process abstraction
28:04
which protects those files and exports them to programming and yes somebody brought up the imagine
28:11
programming in ones and zeros i can say that i've done that and it's
28:16
not pleasant but anyway moving moving on here so
28:22
here's the operating systems view of the world when there are multiple processes so each process gets its own set of
28:28
threads and address spaces and files and sockets okay and they might run
28:33
a program with its own linked libraries okay but what's interesting about this
28:40
point of view is these processes are actually protected from each other okay so the operating system translates from the
28:46
hardware interface down below to the application interface and each program gets its own process
28:52
which is a protected uh environment all right and so in addition to illusionist
28:58
we're going to talk about another thing that operating systems do which is referee which is manage the protection
29:03
isolation and sharing of resources and this is going to become particularly important when we talk
29:09
about global scale systems you can imagine we talk about storage that spans the globe with many
29:16
uh individual operating systems running at the same time each of which could be corrupted in one way or another
29:21
you kind of get to the interesting question of well how do you protect anything and this is where the referee point comes into play
29:28
and so here i'm going to show you we're going to now be more consistent with our coloring for what's going forward but here we
29:35
have compile program number one and number two each of them are linked with system libraries you're going to learn about the c library
29:41
uh very shortly like i said and they are running independent of each
29:46
other and however in this simple example there's only one processor
29:51
okay so that one processor and one core by the way for before somebody asked where say one
29:57
processor one core um and how can these two things appear to be running at the same time well
30:04
we start out with one of them running so the brown one's running it's got it's using the processor registers it's got a
30:11
process descriptor and thread descriptor and memory you'll learn about those as well and it's busy getting cpu time okay
30:19
the green process is not running but it is protected okay and so now how do we get the
30:26
illusion that there's more than one processor or that each process has its own processor well we uh each process has its own process
30:34
descriptor in memory and then the operating system has to have some protected memory as well
30:39
and what we're going to do periodically is we're going to switch from brown to green and vice versa okay so here's the
30:44
example of going from brown to green so the brown device has this process descriptor here
30:50
the green one has the other the green one and what we do is we go through a process switch
30:56
where the registers are stored uh through the os into their own process descriptor block
31:02
and then the green ones are reloaded and what happens is voila the registers are now pointing at the green memory
31:09
and the green one picks up from exactly where it left off okay and then a little bit later our timer is going to go off and we're going
31:15
to switch back the other way and if we do this frequently enough you get the illusion that multiple processes are running at
31:20
the same time and uh we're going to talk about this how this works in detail so um i can uh very confidently say that
31:29
in a few weeks you will have a very good idea of how this works so but at the high level it's very
31:35
simple we're just switching the processor back and forth between brown and green and as a result we get
31:40
the illusion that they're both running and notice that what do i mean by uh the
31:46
illusion well the process one can pretend like it's got 100 of the processor and process two can pretend
31:52
it's got 100 of the processor and things just work out okay and that's up to the operating
31:57
system now the question that's interesting here and does a program become a process when
32:02
loaded into memory a program becomes a process that's a very good question for uh next week but when a program becomes
32:10
a process when the binary has been loaded into memory and into the proper os structures so it
32:18
has to have a a process structure allocated for it and it has to be put into the scheduler
32:25
queue and so on once that's happened now that process is an instantiation of a running program
32:32
so going a little further to that question that was there both brown and green could actually be
32:37
the same program running in different instances with different state so we could have
32:43
uh we could have one program two processes each of them doing something different and this is uh typically what would
32:50
happen if you were logged into a shared machine and you were both say editing with emacs or vi uh each of you
32:55
would have your own state okay so um and then the interesting thing about shared data we'll get to
33:02
um in a little bit uh next week probably but uh yes so you guys are way ahead of me so
33:09
that's good so now the question about i will say one uh answer this question here about what does it mean when
33:15
a process is some percent of the cpu that literally means what it says if process 1 has 90 of the cpu and
33:22
process two has ten it means that uh if you were to look from uh ten thousand feet
33:28
you would look down and you see that process one gets the cpu ninety percent of the time and process two gets a ten percent of the time
33:34
okay and mostly what you're going to see is that there might be one thing that's getting
33:39
most of the cpu and the rest of them are getting very little of it and that's because they're mostly sleeping or
33:45
waiting on io typically but if you look carefully and you uh you add everything up you'll
33:51
actually get a hundred percent okay but that oftentimes if uh
33:57
something's mostly idle most of that time comes up as the uh the idle process which we'll talk more about
34:02
too okay so let's talk briefly about protection so um here we have brown and green um
34:09
but i said they were protected from each other so what happens if process two reaches up
34:15
and shows uh tries to access brown's memory or tries to access the operating
34:21
system or tries to access storage which is owned by some other user what happens is protection kicks in the
34:29
operating system and voila we uh we basically give that process the
34:35
boot and typically cause a segmentation uh fault dump core and uh the green process is stopped now
34:42
uh the question about more than a hundred percent uh is an interesting one it really
34:48
depends on how the statistics are reported uh if you have multiple cores you have say four cores
34:54
uh in one view of the world you could have up to four hundred percent execution um in another you could say uh only if
35:01
you use all four cores you get 100 so you have to be very careful about what the reporting statistics are because i've seen them both ways
35:09
okay but if you have more than 100 then you definitely have it reporting uh multiple cores where each core is 100
35:17
okay so uh does one cpu equal one core i'm going to say yes uh for now
35:26
um and just know that that's not the whole story we'll we'll go a little further for now but for now
35:32
today you can certainly think of one cpu equal one core for this lecture absolutely um one cpu
35:38
chip often has many cores and so we're not gonna go there today but we're gonna go there so um
35:45
this protection idea is really the os synthesizes a protection boundary which
35:51
protects the processes running on top of the virtualization from the hardware and prevents those processes from doing
35:58
things that we've deemed not correct that are not part of the protection okay and the virtual memory uh
36:06
which we're going to talk about as we go is exactly what i just said here so that i didn't talk about this in terms
36:12
of virtual memory but one of the reasons that the green process isn't able to reach out and touch the brown memory is that
36:19
virtual memory prevents it um but this uh reaching out to memory you're not supposed to have access to is
36:26
is uh can be shown you know reaching out past the boundaries of what the operating system has mapped for you in
36:32
virtual memory as well so think of today's lecture as giving you some of the ideas at the high level which we're going to drill down to
36:39
in a couple of lectures so this protection boundary is again part of the virtual machine
36:44
okay abstraction somehow we've got these networks which have little packets with mtus that are 200 bytes and what have
36:51
you we've got storage which is a bunch of blocks we got you know controllers which do a bunch of
36:57
complicated stuff you as a programmer don't want to think about the net about the
37:02
individual hardware because if you had to do that you'd be uh you know you wouldn't be getting
37:09
anything done and so part of what the os does is it really puts these protection boundaries in
37:15
gives you a clean virtualization precisely so you can program without thinking about those things
37:20
and you can program without worrying about somebody else trying to hack in as well so that's the idea
37:25
there's an interesting question on the chat here about whether the java virtual machine would be an os and yes there are points of view in
37:32
which uh the java virtual machine could be considered an os so um let's save that question for
37:39
another day but bring it back if it looks like we're going that somewhere where that's appropriate
37:45
so the os isolates processes from each other it isolates itself from other processes
37:50
and even though they're all running on the same hardware um so that's an interesting challenge which
37:57
we're going to tell you how it works okay so finally the operating system has a bunch
38:04
of glue that it provides which are common services so you may not have thought it this way but
38:09
um if you have a good operating system it's going to give you a file system so you're going to get a storage
38:14
abstraction or it's going to give you windows and that properly uh take in
38:20
mice mouse clicks and so on or it's going to give you a networking system that can talk from berkeley to beijing and back
38:27
without worrying about packets okay and so these common services are actually typically linked in with libraries and
38:34
those libraries are things that you come to to uh depend on when you're writing a program so really an operating
38:40
system if you were to look at its functionality referee illusionist glue all of these things are
38:45
part of what an operating system might be considered doing uh what gets interesting when you set up
38:51
non-mainstream operating systems like uh if i don't run out of time i'll briefly talk about the martian rover
38:57
uh for instance um you might try having stripped down versions not as
39:03
much uh functionality to try to run on simpler hardware uh or in a less malicious environment
39:10
where there might not be somebody hacking in and so many times people build specialized operating systems
39:17
which perhaps don't have all the protection internally or maybe they don't have all the storage
39:23
services that they might that you might see here etc and that's doesn't make it any less an operating
39:29
system it makes a more directed operating system at a particular task so so finally um the os some of the
39:36
basics are i o and um the uh clearly i've just said
39:42
kind of that we're providing the ability for storage and networks to have a nice clean abstraction
39:48
into the hardware that we can deal with okay and that's the common services
39:53
um so uh there was a question here about flipping transistors and heat
39:59
i tell you what i promise uh as a computer architect to talk about that in a few lectures for you if that's
40:05
interesting um uh is there a smallest os well uh there was something that david culler put
40:10
together in the early 2000s called tiny os which is pretty small okay so finally uh the os maybe gives
40:19
you some look and feel so uh maybe you have display services there is an interesting point uh
40:27
back to what i talked about earlier in the lecture here is windowing part of the operating system
40:34
is the browser part of the operating system well perhaps depends on what operating system
40:40
so for instance microsoft windows went through a phase the windows nt
40:46
initially had was a micro kernel type operating system and the windowing
40:51
system was outside of the kernel and then they decided they weren't getting enough performance and so they
40:56
went the opposite direction and put the windowing entirely inside of the kernel which is almost like a a reactionary
41:04
response and so you could have windowing both in and out of the kernel and the distinctions there have to do
41:10
with protection security durability reliability some of those questions come up and hopefully you'll have enough to
41:18
judge where you think it belongs as we get further into the lecture or further into the class
41:26
um and then finally we got to deal with power management and some of these things which only really show up on portable devices but these are all
41:32
potentially managed by the os so so what's an operating system
41:38
referee referee illusionist glue many different possibilities so why should you take 61c well other
41:46
than being one of the best classes in the department if i do say so myself some of you
41:51
uh will likely uh i said cs i said 61c i'm at 162. my
41:58
apologies boy i'm slipping up here tonight but some of you are actually going to
42:04
uh design and build operating systems so by the way just to be clear i was saying that cs162 is one of the best classes
42:11
but you shouldn't quote me on that i'll get in trouble but some of you may actually uh design and build operating systems uh
42:19
in the future and it'd be very useful for you to understand them okay uh many of you will create systems
42:27
that utilize core concepts and operating systems so this is uh more of you uh it doesn't
42:33
matter whether you build software or hardware or you start a company or a startup the concepts you lose
42:39
that you uh basically use in 162 are ones that are going to go across very easily to many of these
42:46
different future tasks that you're going to do and so you're going to learn about scheduling
42:52
and uh well you could schedule in the hardware if you're designing processors you can schedule in
42:58
the lower levels of the os if you're building a core os you could schedule uh in a big cloud
43:04
system if you're building cloud apps and so the ideas that we learn here actually go across to many different places and
43:12
we'll even talk about some cloud scheduling as we get a little later in the term um all of you are going to build apps i
43:17
guarantee it as you go forward okay and you're going to use utilize the operating system and so the more you
43:23
understand about what's going on the more likely you are to a not do something
43:29
that uh was not a smart thing to do hopefully you'll learn about locking
43:34
you'll learn about concurrency you'll learn enough about the right way to design some of these systems that you're going to write amazing bug
43:41
free software as opposed to almost amazing very buggy software
43:47
okay um so who am i so my name is john kubatowicz most people call me professor
43:52
kuby maybe because they can't pronounce my last name but i have background in hardware design
43:58
so i did there's a chip i designed for my phd work which was one of the first shared memory multi-processors that also did message
44:05
passing called alewife i have backgrounds in operating systems i worked for project athena at mit
44:11
um as an os developer device drivers and network file systems worked on clustered high availability
44:18
systems we had a project uh for a while in the par lab called tessellation
44:24
which was a new operating system we were developing for multi-core processors
44:29
i did a lot of work in peer-to-peer systems so the ocean store project this was our logo here of the scuba diving
44:34
monkey um yeah i was addressing the idea of storing data for thousands of years
44:41
um and we were pretty much one of the first cloud storage projects before anybody talked about the cloud back in
44:46
the early 2000s and so some of the concepts i talk about at the end of the term will come from
44:52
some of those ideas um i also do some quantum computing um and uh perhaps you could get me to
44:59
talk about that at some point but it's a little off topic for this class and most recently i've been uh
45:06
working in the internet of things or the swarm specifically i have a project called the
45:11
global data plane which is looking at uh hardened data containers we like to use the analogy
45:17
of these shipping containers that everybody sees down at the port of oakland uh where these shipping containers are
45:22
cryptographically hardened containers of data that can be moved around to the edge devices and back into
45:29
the uh back into the cloud and um are ideal for edge computing and so
45:35
we'll talk some about some of these ideas as well and if any of you are interested in um
45:41
doing research in that that's certainly something you could talk to me about all right um and uh i will
45:47
say that quantum computing is a real thing becoming more real as we go it's got to
45:53
be real because google and ibm talk about it all the time now so um that's a little bit of a joke but uh
45:59
we have a great set of tas this term um and uh neil uh kulkarni and akshat gokoli
46:07
are co-head tas and um and we have a set of really good tas
46:13
and so i'm very excited about our staff and uh i will tell you a little bit about where
46:19
we're at in terms of scheduling sections we haven't um
46:25
the sections are still tba and i'll say a little bit more about why that is in a second um okay so
46:33
um let's talk a little bit about enrollment uh the class has a limit of 428 i just
46:40
raised it and it's not going to go any higher so um probably won't make the class any
46:46
larger uh there's one circumstance where that might happen but i think it's unlikely
46:52
at this point um this is an early so um i will say something here so uh running
46:59
a class virtually in the middle of a pandemic especially something like cs162 is a serious challenge
47:05
and so um what we're doing is you're going to have a a pretty good i would say an excellent
47:14
ratio of students to tas this term and uh and that's to make sure that
47:19
things all be um smoothly running okay um and so probably won't make the class
47:26
any larger um the other thing to keep in mind is this is an early drop class okay so september 4th which is a
47:33
week from friday is the drop deadline and what an early drop class means is it's really
47:38
hard to drop afterwards okay so the next two weeks you need to make sure
47:46
that uh you want to be in the class okay because if you are still in the class and you get past that
47:53
early drop deadline um you either have to burn your one uh special drop late uh
48:00
token that you get as a student or there's some appeals process that doesn't always work so
48:06
um so the early drop deadline is really there to make sure that when you guys start working in groups
48:12
it's going to be stable okay we put we instituted that because what would happen is people would form
48:18
their groups and students who weren't entirely serious about
48:23
the class ended up dropping out on their project partners and that got to be a problem so what
48:30
we need to do in the next two weeks is everybody needs to make sure they want to be in the class and if you don't you should drop early
48:38
so that people could get in because we currently have a wait list that's uh was 75 or so the
48:43
last i checked the uh other thing which i'm gonna say
48:49
more about in a moment but we're very serious about requiring cameras okay for discussion sessions
48:56
for uh design reviews and even for office hours okay and we're going to
49:01
certainly use them for uh exams so if you don't have a camera
49:06
yet you need to find one the only place in this class where you're not going to want to turn on your camera is lecture
49:11
because having we currently have 328 people on the the chat there um and so
49:17
that would be bad um i think with the wi-fi uh issues people are asking about
49:23
let's just do your best okay zoom tries to adjust a little bit and we'll we'll deal
49:30
with problems on a on a case-by-case basis but i'm going to
49:35
tell you more about this in a moment but really having a class like this all virtual
49:41
is very hard unless people interact a little more normally and so
49:47
that's really requiring people to be able to see you okay um if you're on the wait list uh like i
49:54
said earlier we kind of maxed out sections in ta support so if people drop uh they're gonna we're gonna
50:00
automatically move people from the the uh waitlist into the class
50:06
so here's the thing you should def absolutely not do and if you have friends who are uh
50:13
you know we're just on the class and are thinking they're not going to take the class make sure that they either get
50:19
themselves off the wait list or they do all the work in the class because uh as i'm going to mention a
50:25
little bit if you're still on the wait list and
50:30
a spot opens up we will enroll you in the class and you'll be stuck of course with an amazing class as we
50:36
mentioned earlier but if you're not keeping up that could be a problem if you because we have occasionally had people discover
50:43
weeks into the class that they were enrolled and uh you know couldn't get out of it
50:50
so don't be one of those people okay um now uh
50:56
the question about discussion sessions i'll say a little bit more about them in a moment okay but how do we deal with 162 in the
51:04
age of cobit 19 well if you look at this particular uh word play here we've got collaboration
51:10
in the middle we've got to remember people and we've got to figure out how to combine all of you together
51:17
in your groups and produce something successful so this is challenging and i i know this is not the term you thought
51:24
you were getting this fall when you uh you know when you thought about coming to berkeley and i apologize
51:31
but uh most of you i think experienced the end of last semester unfortunately um but
51:37
collaboration is going to be key okay so things are considerably different i would say this term even
51:42
than they were last term because we're starting out fully remotely so you don't even get to see anybody in person probably um
51:51
maybe some of you will get to see each other but i would bet that the bulk of you don't um most important thing is people
51:59
and then interaction and collaboration so i put up something here to you all remember you know i fondly remember coffee houses
52:06
this is what they kind of look like you know you sit with people and you drink beverages of choice i'm going to say
52:12
coffee to get keep from getting in trouble and uh you discuss things okay
52:17
so this is how groups ought to work okay and the question is how do we do
52:22
this uh when people are all remote and so first of all uh we're gonna have
52:28
to use it's gonna work it's gonna require work okay i hate to say this but the way we make this uh turn out well
52:36
is we've got to work at our interactions because as you well know if you don't look at
52:42
anybody with cameras on or whatever and you just exchange email that can go south very quickly
52:48
even when you didn't intend to imply something and everybody gets their feelings hurt things are just not
52:54
working out well so we've got to figure out how to bring everybody along with us so we don't
53:01
uh lose anybody and if you notice here by the way these people are holding hands that's virtual so we're not suggesting that you
53:07
um don't socially distance when you're bringing people along but the camera is a part of this okay so
53:14
this is call this an experiment um but cameras are going to be an essential component
53:20
um you got to have a camera and plan to turn it on and if you have issues with spectrum let's see if
53:25
figure out ways of maybe lowering the bandwidth a little bit but um you certainly need it for exams
53:31
okay so if you don't have a camera you got to make sure you got enough spectrum and a camera for the exams
53:38
um and you're going to need it for discussion sessions design reviews and office hours possibly even
53:43
that's going to depend on whoever's running the office hours um we uh i'll get to section this week in a
53:50
moment but yes we do have section this week um but the thing about cameras is it
53:56
gives the ability to at least approximate what we used to be able to do when we sat physically
54:02
in person in fact i may even in fact not even me we are probably going to
54:07
give extra credit points for screenshots of you and your group meeting on a regular basis
54:13
drinking a beverage of choice and talking to each other okay so this is the kind of thing that needs to
54:18
be strongly encouraged um even before we had a pandemic
54:23
i i had groups that uh somehow despite the fact that they could
54:28
be never met uh the whole term okay and
54:34
this was uh got bad and by the end of the term the group uh all of the members were
54:40
upset with each other they um you know the project failed and they all
54:47
got bad grades and this was just a bad scenario and it didn't have to happen that way because
54:52
they should have been meeting they should have been looking at each other while they were talking and it didn't happen so this is
54:58
our experiment okay and so cameras are a tool uh not of the man
55:05
they are a tool of collaboration okay um so we want to bring back personal
55:11
interaction okay even though we're on either side of fences okay humans are really you know even
55:18
computer scientists are not good at text only interaction um so
55:23
uh we are going to require attendance we're going to take attendance at discussion sessions and design reviews
55:30
um with the camera turned on okay so and hopefully that's clear
55:36
any other questions on the camera you can uh why don't you type your
55:43
questions and people turn off their mic if they're
55:48
not asking a question actually uh type your questions too all right
55:54
so infrastructure well it's only infrastructure you can't come see us but um we have
56:02
website uh which you've probably all gone to cs162.eats.berkeley.edu
56:07
that's going to be your home for a lot of information related to the course schedule we also have piazza so hopefully you all
56:14
have logged into piazza already assume that piazza is the primary place where you're going to get your
56:20
information i'm also going to be posting the slides early as have been asked several times
56:25
on the website on the cl the class schedule and when the videos are ready they'll be
56:31
posted on the class schedule as well so you'll be able to uh get everything related to the schedule on the website
56:37
and then piazza is kind of everything else okay the textbook is this
56:43
principles and practices of operating systems it's a very good book the suggested
56:49
readings are actually in the schedule and so you try to keep up with the material you can get a red version
56:56
on text of what i talk about and i think those two together help a lot there are also some optional
57:02
things you could look at so there's uh i know david culler really liked this operating system three easy pieces book
57:08
the linux kernel development book some of these are interesting maybe to look at as a as a
57:15
supplement one thing that you may not have known is if you log in with your berkeley credentials
57:21
uh to the network which i think you need to use a virtual
57:26
vpn to do that but you can actually get access to all of the o'reilly animal
57:32
books over the network as well that's something that berkeley's negotiated with the digital library which is pretty
57:37
cool and then there's online stuff okay so if you look at the course website we've got
57:43
appendices of books we've got sample problems um we've got things in networking
57:48
databases software engineering security all that stuff's up there old exams
57:54
so the first textbook is definitely uh considered a required book you should try to get a copy even if it's only an
58:00
e-book there's also some research papers that are on the resources page
58:06
that i've put up there and we'll actually be talking about some research as we get later in the term so
58:12
use that as a as a good resource so the syllabus uh well we're going to
58:18
start talking about how to navigate as a system programmer we're going to talk about processes io networks virtual
58:23
machines concurrency is going to be a big part of the early parts of this class so how do the threads work how does scheduling
58:29
locks deadlock scalability fairness how's that all work we'll talk about where address spaces
58:34
come from and how to make it work so we'll talk about virtual memory and how to take the mechanisms
58:40
and synthesize them into interesting security policies so virtual memory address translation
58:45
protection sharing we'll talk about how file systems work so uh we talk about device drivers and
58:52
file objects and storage and uh block stores and naming and caching and how to
58:57
get performance and all of those interesting things about file systems which you probably haven't thought about
59:03
and in the last uh sort of couple weeks of the class we'll even talk about how to get the file system abstraction
59:09
to uh span the globe uh in the cloud storage system so that'll be interesting we'll talk like i
59:15
said about distributed systems protocols rpc nfs dhts uh we'll talk about
59:22
cord we'll talk about tapestry and some of those other things um and we'll also talk about reliability
59:30
and security to some pretty big extent there's a question in the chat about cloud uh systems and why they haven't really
59:37
uh taken over as operating systems and i think maybe they have more than you might think i
59:42
think the the cloud has really become part of our day-to-day lives and things that people call
59:48
the cloud operating system maybe where they put capital t c o s or something may not have
59:55
taken over but a lot of other mechanisms have been synthesized together in a way that
1:00:00
you haven't thought about so hopefully by the end of the term we'll actually uh you'll have enough
1:00:09
knowledge to evaluate that question for yourself as to you know what is up with the cloud and
1:00:15
is it really a monolithic thing or is it a bunch of mechanisms and where is that at
1:00:21
okay so we learn by doing in this class so there's uh a set of homeworks and each of them is
1:00:29
kind of one or two weeks long there's one that you've got to get going right away which is
1:00:35
um you need to get going on homework zero so this is one of the things that we do
1:00:41
in the very first week it's already been released i believe and you should get moving on it and it's basically learning how to use
1:00:47
the systems and there's also a project zero which is done individually and you should get
1:00:53
working on there too so this class is as much about knowledge as it is about
1:00:59
um uh actually doing things i should say that the other way it's as much about doing things it is about knowledge so
1:01:05
you're gonna do build real systems okay and um and you're going to learn some
1:01:11
important tools as you do that and they're either going to be done individually or they're going to be done in groups
1:01:16
okay um there was a question about kafka and cassandra probably we'll get some
1:01:23
concepts from them a little bit later okay so a big thing to learn about from this
1:01:30
slide is get going on uh homework zero and and uh project zero will probably get
1:01:35
posted soon and both of those are things to do on your own without your group so group projects have four members
1:01:43
never five or never three okay it's four three is a very serious justification
1:01:50
requirement um you must work in groups in the real world and so you learn how to do it here
1:01:56
um and all of your group members have to be in the same section uh with the same ta okay
1:02:04
and so that's why the sections that you attend and you are going to attend sections in the next couple of weeks uh
1:02:10
are just any section you want um because we have don't have your groups yet and once we have your groups
1:02:16
then we will uh assign you to sections and go from there and you should attend the
1:02:21
same section and that's when the requirements for attending section will kick in and we do
1:02:27
have a survey out on time zones and so on to try to get an idea where the best place to put some of these sections are
1:02:34
so communication and comp cooperation are going to be essential uh regular meetings with camera turned
1:02:39
on is going to be important you're going to do design docs uh
1:02:45
and be in design meetings with your ta and i will tell you yes you can use slack and messenger or
1:02:52
whatever your favorite communication is but if that's the only thing you do it's not going to be great okay you got
1:02:58
to have your camera you got to get together and see each other the group
1:03:04
your groups are actually going to have to be formed by i think the
1:03:10
third week of classes it's in the schedule take a look but when we get into groups i'm going to
1:03:15
actually have a lecture half lecture where i talk a bit about mechanisms for groups as well okay
1:03:24
and uh sort of ways that you can cope with the typical problems that groups
1:03:29
have and sort of what are some good uh good tools there to give you a little idea but um
1:03:34
short answer is you've got to decide groups very shortly and we do that typically after the early
1:03:40
drop date because at that point in theory people are stably going to be in the class and we're going to have some
1:03:46
mechanisms to help you form groups there's going to be a piazza uh looking for a group
1:03:51
kind of uh thread we we may even have um some zoom uh
1:03:58
um room set up for people to sort of you know i don't know interview your group members or talk to them
1:04:05
we have a couple of different things we've been thinking of just to try to get your groups together but keep in
1:04:10
mind you want to have four members in your group okay not not five and three
1:04:15
is um probably only under serious justification okay
1:04:22
um and you're gonna be communicating with your ta who's like a supervisor in the real real world so this group thread here is
1:04:30
very much like um what you're going to run into when you finally exit berkeley and
1:04:36
confront the real world how do you get started well there's
1:04:41
going to be a survey out okay so the um the the question in the chat about
1:04:47
uh tbd yes so the group uh you uh we're assuming that
1:04:53
many of you might not have group members yet and it's also the case that the um final discussion session times
1:05:00
haven't been decided only for the next couple of weeks until groups are formed okay um there's going to be a time zone
1:05:07
survey or a survey out you probably have already seen it i think it was released on piazza but you need to uh fill that out let me
1:05:14
know where everybody is okay i want to know uh if you're in uh if you're in asia or if you're you're
1:05:21
in europe or you're in new york or whatever okay um get going on homework
1:05:27
zero project zero is not quite out yet but it will be very soon okay um but uh homework zero kind of
1:05:34
gets you going on things like getting your github account and uh registration and getting your
1:05:39
virtual machine set up and get familiar with the 162 tools and so on and how to submit to the auto grader
1:05:45
so project is so homework zero is up and it's something to get going on right away and we will announce as soon as
1:05:51
project zero is up it's gonna be out soon um sections on friday attend any
1:05:56
section you want uh that we will post the zoom links if they're not already posted
1:06:01
um very shortly and you'll get your permanent sections after we have our group set up
1:06:08
okay so you're going to to prepare for this class you're going to have to very be very comfortable with
1:06:14
programming and debugging c you're going to want to learn about pointers and memory management and gdb
1:06:20
and uh much more sophisticated and large code base than 61c and so we actually have a review session
1:06:27
on thursday um the third of september uh to learn and review quickly about c and
1:06:35
c plus plus concepts and um just uh stay tuned we're going to get that out
1:06:41
and uh consider going just to give you a refresher the resources page has some things to
1:06:47
work uh look at there's some ebooks on get and see there's a programming reference
1:06:52
that was put together by some tas a couple of terms ago and so first two sections are also about
1:06:59
programming and debugging okay all right um the uh tentative breakdown for grading
1:07:06
is there are three midterms there's no final the midterms are going to be zoom proctored and camera is going
1:07:12
to be required uh just so you know please figure that as part of the class
1:07:18
okay and so um get yourself camera um so that's about 36 percent um 36
1:07:25
projects 18 homework 10 participation um and uh
1:07:33
let's see so um yes zoom proctoring projects i've already talked a lot about homeworks you've heard about a little
1:07:40
bit um as far as the midterms are concerned um we are going to set times after we know more
1:07:46
about where people are okay midterms are um
1:07:52
i have we haven't entirely decided but they're either gonna be two or three hours long each okay so the other thing i want to talk
1:07:59
about here is personal integrity which is there is an academic honor code
1:08:04
which is a member of the uc berkeley community i act with honesty integrity and respect for others
1:08:10
uh you guys can take a look at it i strongly suggest you look at it okay this class uh is
1:08:18
very heavily uh collaborative between you and your group
1:08:24
but it should not be across groups okay or across other people on homeworks so things like
1:08:29
explaining a concept to somebody in another group is okay discussing algorithms or maybe testing
1:08:35
strategies might be okay discussing debugging approaches or searching online for generic algorithms
1:08:42
not force answers these are all okay okay these are not things where you're
1:08:47
getting specific answers to your labs and homeworks sharing code or test
1:08:53
cases with another group not okay copying or reading another group's code not okay copying or reading online code
1:09:01
or test cases from previous years not okay helping somebody in another group to
1:09:07
debug their code not okay so sitting down for a long session of debugging to help somebody
1:09:12
um without you know maybe thinking you're not copying code in i'll tell you a long debug session has a tendency to
1:09:19
to cause the code to become looking like your own code so that's not okay
1:09:24
okay and we actually compare project submissions and we catch things like this okay we actually caught a case
1:09:30
um once where somebody sat down and debugged with another group and helped him out
1:09:37
and didn't do any direct copying or at least they claimed not but when it was done the code looked so close that the automatic tools caught it
1:09:44
so don't do that and the other thing not to do is don't put a friend in a bad position by
1:09:50
demanding that they give you their answers for homework okay we had several cases uh we've had several cases
1:09:56
like that recently where one person was having trouble with old work and they they kind of guilted a partner or a
1:10:03
friend into giving them an answer and that gets both of them in trouble so don't
1:10:08
just don't do that okay do your own work and by the way to help this we're trying for
1:10:14
the first time during the term to to not have um a
1:10:19
curve in this class we're going to actually do an uncurved version of this we haven't put up the thresholds yet
1:10:25
but we'll see how that works but um please just don't put your friends in bad positions by by
1:10:31
making them give you code because they get in trouble as well and it's just not worth it and you don't learn what you could learn
1:10:36
by actually doing the work okay it's kind of what's the point of being in the class in the first place so all right um the goal of the lecture
1:10:44
is interaction and so lots of questions all right we already had a bunch of questions today that's great um i'm hoping that uh this continues
1:10:52
okay um you know sometimes it may end up that we don't quite get through the topics i
1:10:58
was hoping but uh we'll uh it's much better to have interesting questions um and what i can do in a virtual term
1:11:06
like this is i can even have some supplemental uh extra you know 30 minutes of lecture
1:11:11
i can post or something if we don't quite get through the stuff i thought we would so let's give this a try and see if we can
1:11:16
make this virtual term as good or better than it would be under normal circumstances all right
1:11:23
and again if you have more questions about uh logistics you know piazza the class
1:11:30
website those are your two best uh places to look for information
1:11:35
so let's finish up here in the last 10 minutes or so and ask a little bit more about what makes operating systems exciting and
1:11:41
challenging okay this is what makes operating systems exciting okay the world is a huge distributed system we showed you
1:11:48
the uh what people were calling the brain view earlier kind of like that of the network
1:11:54
but the thing that's interesting about it is all the devices on there from massive clusters at one end that span the globe
1:11:59
um down to little mems devices and iot devices and everything in between okay this is uh you know modern cars for
1:12:07
instance have hundreds of processors in them refrigerators have processors and web browsers i mean we've got huge cloud
1:12:15
services uh we've got cell phones little devices everywhere and all of this together is one huge system this is exciting i mean
1:12:23
why why does this work in the first case and what's its potential okay um so you know this is why i think
1:12:30
operating systems are so exciting because it's what makes this all work without them there would be chaos and
1:12:36
things just wouldn't work so of course you've all heard you wouldn't be at berkeley if you hadn't
1:12:41
many times about moore's law so the thing about moore's law which i like and i always want to mention is over the um moore's law basically
1:12:49
says that you know for instance you get twice the transistors every 1.5 years or so
1:12:54
um for many years although that's starting to disappear on us now but what you may not know so that's an
1:13:01
uh an exponential curve or a straight line and a log linear curve what you may not know is gordon
1:13:06
moore was actually asked at a conference once what he thought was going to happen in a log
1:13:12
linear graph on the fly at the conference he put down a couple of points drew a straight line and say well this
1:13:18
is what's going to happen uh far into the future now normally that would be uh
1:13:24
ridiculous and laughable except he was bright which was pretty amazing okay
1:13:29
so what what's the thing about moore's law the thing about moore's law is it allows you to make zillions of
1:13:35
interesting devices because there's so many transistors that you can can shove into a little bit of a device
1:13:42
of course the downside which happened back in the early 2000s was that um putting these transistors uh
1:13:49
increasingly on chip kind of ran into problems with capacitance and power such that you weren't able to make an
1:13:55
individual processor as fast it used to be that you could uh you know wait a few years and get twice
1:14:01
the performance of a machine that you're currently working with somewhere around the 2000s that stopped
1:14:06
and suddenly what did you do well suddenly people had to make multi-core processors and lots
1:14:12
of parallelism and so you know from an operating system standpoint this is par for the course because uh
1:14:19
you know i already showed you a huge system with billions and billions of devices and so yeah so the fact that chips have
1:14:25
multiple cores on them is it's cool it's uh you know it's enabling of lots
1:14:31
of stuff but it's just kind of that's the way it is and it's interesting about how we get around that complexity
1:14:37
okay so around the 2000s we suddenly had multi-core the power density thing i think is a
1:14:43
funny way to look at this if in 2000 if instead of
1:14:49
basically trying to keep making the processors grow as fast in performance as they were
1:14:54
if you had done that what would happen is we would have chips that had the the power density of a
1:15:00
rocket nozzle um and you could imagine putting a laptop like that on your lap might be a
1:15:05
little uncomfortable so power density capacitance a lot of things is what kind of led people to
1:15:11
suddenly make multi-core instead of making things faster but they did that okay so by the
1:15:17
mid-2000s we had many cores on a chip okay and so parallelism's exploited
1:15:24
at lots of levels all right and uh somebody pointed out the the stock of intel and amd went up
1:15:30
hugely um that's true uh but that was because they were delivering something that everybody needed which was
1:15:36
lots of processors on a chip all right and the problem of course is as you're
1:15:43
well aware moore's law is ending and it's not officially well
1:15:48
it's officially over in the original growth but people are still shoving a few more transistors on there
1:15:54
but unless there's some fundamentally new technology um we're basically going to see the end
1:16:00
of that growth of more uh you know smaller transistors but it doesn't mean that people aren't still
1:16:07
shoving lots of devices together and connecting them with networks it just means networks become more important
1:16:13
okay and uh by the way vendors are moving to 3d stacked chips and all sorts of cool ways of
1:16:19
having a single device have even more transistors on it even if moore's law is ending so um i have no doubt that things are
1:16:26
going to continue uh quite a ways into the future the other thing is storage capacity keeps
1:16:31
growing okay we've got uh various moore's law-like graphs of storage
1:16:37
um society keeps getting more and more connected and so we have more devices more storage and more devices
1:16:46
more storage more people means more need for operating systems which is why you're in the right class
1:16:53
now our capacity keeps going up okay people need more connections okay and they're they're at the small
1:16:59
scale and the large scale but not only pcs we have lots of little devices
1:17:06
we've got lots of internet of things devices you saw this graph earlier i showed you but we've got little
1:17:12
temperature sensors and fitbits and things you carry on your body and things you put in your cars and all
1:17:18
the way up to the cloud okay so what's an operating system again
1:17:23
it's a referee it's an illusionist it's glue that helps us build these huge interesting systems and that's what
1:17:30
you're going to learn about this term the challenge which i'm going to kind of close with the challenge is complexity
1:17:36
okay applications consisting of many software modules that run on many devices
1:17:42
implemented on many different hardware platforms running different applications at the same time failing in
1:17:48
unexpected ways under attack from malicious people leads to
1:17:54
craziness and complexity right and it's not feasible to test software for all possible environments
1:18:00
and uh combinations of components and so we're going to have to learn how to build these complex systems in ways that
1:18:06
may basically work and some of that is going to be learning just how to design systems that are correct by design
1:18:12
rather than correct by accident okay the world is parallel if you
1:18:18
haven't gotten that by now here's an example of from 2017 the intel sky lake 28 cores uh each core has two hyper
1:18:26
threads so it's 58 threads per chip and then you put a bunch of these chips together and you get a huge parallel system in a
1:18:33
tiny box and you put a bunch of boxes together and pretty soon you got the world okay uh
1:18:40
yes and 28 times two is not 58 very good so with that uh not only do we have
1:18:47
the chips which are interesting but i want you to realize that um the processors are only part of
1:18:54
the story it's this uh all of the i o is the interesting parts and we'll talk about that but it's
1:18:59
not just this processor up here it's everything connected to it it's the devices it's the networks it's the storage okay
1:19:05
so this is um interesting complexity when processing hits the real world and
1:19:12
that's where the operating systems get involved um i thought i'd put up this graph just to leave you with a few things to think
1:19:18
about so here is millions of lines of code um and if you look at the original linux
1:19:24
uh not the original linux but version 2.2 which is quite a you know 15 years ago whatever at least
1:19:33
and you look at the mars rover these are on the low end of this scale but now you kind of look at
1:19:38
uh you know firefox and android and linux31 which is a little bit older now in windows 7
1:19:44
and then you get up into kind of windows vista and the facebook system itself and mac os
1:19:52
and then you look at mouse base pairs here um that's a genetic thing that's 120 million things
1:19:59
you can see that uh our systems are very complicated okay and so um you can go by the way to
1:20:06
this source and get yours you know select the things you want and look at this yourself okay this information is beautiful.net
1:20:12
visualizations a million lines of code it's kind of fun to look at okay so uh you know
1:20:21
the math the mars rover here it is is a very amazing one of you know
1:20:26
there's been a couple of instances of the rover but this particular one one of the first ones was pretty amazing
1:20:31
they were able to to send it up and landed on mars and it ran
1:20:37
for a decade or more um it had very limited uh processing
1:20:43
it's 20 megahertz processors and 128 megabytes of dram and so on and had a real-time operating system
1:20:49
but for instance you can't hit the reset button or you can't debug it very easily and however they were able to set it up
1:20:56
in a situation where they could they figured out some timing problems they had and they
1:21:02
were able to debug it and repair it remotely which is pretty amazing and i'll talk more about that as we go
1:21:08
but you need an operating system on something like this because you perhaps don't want it to run into a
1:21:13
ditch while it's busy taking scientific data or whatever okay and so very similar kind of to the
1:21:19
internet of things in its size so this kind of processing is uh
1:21:24
par for the course for really tiny devices and so we're going to talk about this kind of
1:21:30
device in addition to the really big ones as we go okay so some questions to end with does
1:21:36
a programmer need to write a single program that performs many independent activities and deal with all the hardware
1:21:42
does it have to does every program have to be altered for every environment does a faulty program crash everything
1:21:49
does every program have access to all hardware hopefully the answer to this is no and we'll learn as the term goes on
1:21:57
and operating systems basically help the programmer write robust programs so in conclusion to end today's lecture
1:22:05
operating systems are providing a convenient abstraction to handle diverse hardware
1:22:11
convenience protection reliability all obtained in creating this illusion
1:22:16
for the programmer they coordinate resources protect users from each other and there's a few critical hardware
1:22:22
mechanisms like virtual memory uh which we briefly brought up which we'll talk about that help us with that it simplifies
1:22:28
application development with standard services and gives you fault containment full tolerance and
1:22:34
fault recovery so cs162 combines things from all of these uh areas and many other areas of
1:22:41
computer science so we'll talk about languages and data structures and hardware and algorithms as we go and i'm looking forward to this term i
1:22:48
hope you guys uh all are having a good first week of class and we will see you on monday
1:22:55
all right ciao